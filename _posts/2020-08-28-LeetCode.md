---
title: "LeetCode"
date: 2020-08-28
---
- [Increasing Triplet Subsequence](https://leetcode.com/problems/increasing-triplet-subsequence/)
```java
class Solution {
	public boolean increasingTriplet(int[] nums) {
		int first = Integer.MAX_VALUE, second = Integer.MAX_VALUE;
		
		for (int i : nums) {
			if (i <= first) {
				first = i;
			} else if (i <= second) {
				second = i;
			} else {
				return true;
			}
		}
		return false;
	}
}
```

When a number is bigger than first, It means it will always be a number smaller than it.

- [All Elements in Two Binary Tree](https://leetcode.com/problems/all-elements-in-two-binary-search-trees/)
```java
// inorder first, then merge two array.
class Solution {
    public List<Integer> getAllElements(TreeNode root1, TreeNode root2) {
        int[] a = convert(inorder(root1));
        int[] b = convert(inorder(root2));
        return merge(a, b);
    }
    
    private List<Integer> inorder(TreeNode node) {
        List<Integer> ans = new LinkedList<>();
        if (node == null) {
            return ans;
        }
        
        Deque<TreeNode> stack = new LinkedList<>();
        while (!stack.isEmpty() || node != null) {
            if (node != null) {
                stack.push(node);
                node = node.left;
            } else {
                node = stack.pop();
                ans.add(node.val);
                node = node.right;
            }
        }
        
        return ans;
    }
    
    private List<Integer> merge(int[] a, int[] b) {
        int i = 0, j = 0;
        List<Integer> ans = new ArrayList<>(a.length + b.length);
        while (i < a.length || j < b.length) {
            if (i >= a.length) ans.add(b[j++]);
            else if (j >= b.length) ans.add(a[i++]);
            else if (a[i] < b[j]) ans.add(a[i++]);
            else ans.add(b[j++]);
        }
        return ans;
    }
    
    private int[] convert(List<Integer> list) {
        int[] ans = new int[list.size()];
        for (int i = 0; i < list.size(); i++) {
            ans[i] = list.get(i);
        }
        return ans;
    }
}
```
- [Find the Difference](https://leetcode.com/problems/find-the-difference/)  
Use bit manipulation
```java
class Solution {
    public char findTheDifference(String s, String t) {
        char c = 0;
        for (int i = 0; i < s.length(); i++) {
            c ^= s.charAt(i);
        }
        for (int i = 0; i < t.length(); i++) {
            c ^= t.charAt(i);
        }
        return c;
    }
}
```
- [Remove Duplicate Letters](https://leetcode.com/problems/remove-duplicate-letters/)
```java
class Solution {
    public String removeDuplicateLetters(String s) {
        if (s == null || s.length() == 0) {
            return "";
        }
        
        int[] count = new int[26];
        for (int i = 0; i < s.length(); i++) {
            count[s.charAt(i) - 'a']++;
        }
        
        int pos = 0;
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) < s.charAt(pos)) {
                pos = i;
            }
            if (--count[s.charAt(i) - 'a'] == 0) {
                break;
            }
        }
        
        return s.length() == 0 ? "" : s.charAt(pos) + removeDuplicateLetters(s.substring(pos + 1).replaceAll("" + s.charAt(pos), ""));
    }
}
```

- [Buddy Strings](https://leetcode.com/problems/buddy-strings/)  
There are 2 situation here. First, A is equal to B, then we need to check if there are more than 2 same character
so it won't be changed even after swap each other. Second, A is not equal to B, we need to check if there are more
than 2 different characters, and we have to check if those 4 characters can swap to each other.
```java

class Solution {
    public boolean buddyStrings(String A, String B) {
        if (A.length() != B.length()) {
            return false;
        }
        
        if (A.equals(B)) {
            int[] count = new int[26];
            for (char c : A.toCharArray()) {
                count[c - 'a']++;
            }
            for (int i : count) {
                if (i >= 2) {
                    return true;
                }
            }
        } else {
            int first = -1, second = -1;
            for (int i = 0; i < A.length(); i++) {
                if (A.charAt(i) != B.charAt(i)) {
                    if (first == -1) {
                        first = i;
                    } else if (second == -1) {
                        second = i;
                    } else {
                        return false;
                    }
                }
            }
            
            return (second != -1) && A.charAt(first) == B.charAt(second) && A.charAt(second) == B.charAt(first);
        }
        
        return false;
    }
}
```
- [Merge Two Sorted Lists](https://leetcode.com/problems/merge-two-sorted-lists/)
```java
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if (l1 == null) {
            return l2;
        }
        if (l2 == null) {
            return l1;
        }
        
        ListNode head = new ListNode();
        ListNode cur = head;
        
        while (l1 != null && l2 != null) {
            if (l1.val < l2.val) {
                cur.next = l1;
                l1 = l1.next;
            } else {
                cur.next = l2;
                l2 = l2.next;
            }
            cur = cur.next;
        }
        
        cur.next = l1 == null ? l2 : l1;
        return head.next;
    }
}
```
- [Sort List](https://leetcode.com/problems/sort-list/)
```java
class Solution {
    public ListNode sortList(ListNode head) {
        return sort(head);
    }
    
    private ListNode sort(ListNode node) {
        if (node == null || node.next == null) {
            return node;
        }
        ListNode mid = findMid(node);
        ListNode a = sort(node);
        ListNode b = sort(mid);
        return merge(a, b);
    }
    
    private ListNode findMid(ListNode node) {
        if (node == null || node.next == null) {
            return node;
        }
        ListNode a = node;
        ListNode b = node;
        ListNode mid = node;
        
        while (b != null && b.next != null) {
            mid = a;
            a = a.next;
            b = b.next.next;
        }
        mid.next = null;
        return a;
    }
    
    private ListNode merge(ListNode a, ListNode b) {
        if (a == null) {
            return b;
        }
        if (b == null) {
            return a;
        }
        
        ListNode head = new ListNode();
        ListNode cur = head;
        while (a != null && b != null) {
            if (a.val < b.val) {
                cur.next = a;
                a = a.next;
            } else {
                cur.next = b;
                b = b.next;
            }
            cur = cur.next;
        }
        
        cur.next = a == null ? b : a;
        return head.next;
    }
}
```
