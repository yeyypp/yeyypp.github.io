# Go Timer
How to use timer to invoke methods at specific time.
```
// init a new timer
timer := time.NewTimer(3 * time.Second)

for {
  now := time.Now()
  // invoke methods at every 9 am
  targetTime := time.Date(now.Year(), now.Month(), now.Day(), 9, 0, 0, 0, time.Location())
  todayEnd := time.Date(now.Year(), now.Month(), now.Day(), 24, 0, 0, 0, time.Location())
  
  if targetTime.After(now) {
    timer.Reset(targetTime.Sub(now))
  } else {
    timer.Reset(todayEnd.Add(9 * time.Hour).Sub(now))
  }
  
  <- timer.C
  fmt.Println("do my job")
 }
  
```

# defer
```
func cal() (r int) {
	r = 3
	//return xxx 不是原子操作，变成两步
	// r = 4 先赋值
	// 再执行defer操作
	// 最后执行return
	defer func(r int) {
		r = r + 1
	}(r)
	return 4
}
```

# Go switch
`break` statement only terminates the inner execution `for`, `switch`, `select`
To break a out loop, put a label on the loop
```
Loop:
  for _, v := range list {
    switch v {
    case 1:
      break Loop
    case 2:
      do something
    default:
      do something
    }
 }
```

# Go Embedded type
- [Struct types](https://golang.org/ref/spec#Struct_types)
> Given a struct type S and a defined type T, promoted methods are included in the method set of the struct as follows:
> If S contains an embedded field T, the method sets of S and *S both include promoted methods with receiver T. The method set of *S also includes promoted methods with receiver *T.
> If S contains an embedded field *T, the method sets of S and *S both include promoted methods with receiver T or *T.

# Go Slice
- [Slice Triks](https://github.com/golang/go/wiki/SliceTricks)
- Slice internals  
  The internals data structure consists of a pointer to array, length of the segment and capacity of the segment. If you assign one slice to another, both refer to the same array.
- Growing
```
func AppendByte(s []byte, data ...byte) []byte {
    m := len(s)
    n := m + len(data)
    if n > cap(s) {
        newSlice := make([]byte, (n + 1) * 2)
        copy(newSlice, s)
        s = newSlice
        }
    s = s[:n]
    copy(s[m:n], data)
    return slice
}
```
- Filter
```
func Filter(s []int, f func(int) bool) []int {
    var newSlice []int
    for _, v := range s {
        if f(v) {
            newSlice = append(newSlice, v)
            }
        }
    }
    return newSlice
}
```
- Two-dimensional slices  
  First, allocate a line at a time.
```
picture := make([][]uint8, YSize)
for i, _ := range picture {
    picture[i] = make([]uint8, XSize)
    }
}
```

As one allocation, sliced into lines.
```
picture := make([][]uint8, YSize)
pixels := make([]uint8, XSize * YSize)
for i, _ := range picture {
    picture[i], pixels = pixels[:XSize], pixels[XSize:]
    }
}
```

- When use slice as parameter
  if we use append inside function, we need use pointer of slice as parameter, because the append operation may create a new slice and leave the old slice unchanged.
  if we need to modify the slice, create a variable equals to the value of pointer of slice. Then modify it, and make the pointer point to it at last.
  For example [https://leetcode.com/problems/permutations/submissions/](https://leetcode.com/problems/permutations/submissions/)


```
func help(tem *[]int) {}

func modify(tem *[]int) {
    a := *tem
    a = a[:len(a) - 1]
    *tem = a
    }
```
